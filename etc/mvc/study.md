### 서블릿
html 코드 작성하는게 너무 힘듬
자바 코드를 중심으로 HTML 을 작성함
HTML 이 너무 어려워

### JSP
그래서 제일 고전적인 템플릿 엔진을 사용해보자
1. 라이브러리 추가

HTML 템플릿 중심으로 사용하게됨
- 비지니스 로직과 화면구성이 함께 있음
- 파일도 점점 커진다.
- 유지보수 지옥
- 역할을 구분해야해...!!

### MVC 의 등장
- MODEL, VIEW, CONTROLLER 뭔가 분리되있는것
- 변경의 사이클이 다르면 분리해야한다. UI 고치는 일 vs 자바 비지니스로직 = 둘다 영향이 없다.
- 이렇게 변경의 라이프 사이클이 다르면 분리하는게 좋다.
- 컨트롤러: HTTP 요청을 받아서 파라미터를 검증하고, 비즈니스 로직을 실행한다. 그리고 뷰에 전달할 결과 데이터를 조회해서 모델에 담는다.
- 모델: 뷰에 출력할 데이터를 담아둔다. 뷰가 필요한 데이터를 모두 모델에 담아서 전달해주는 덕분에 뷰는 비즈니스 로직이나 데이터 접근을 몰라도 되고, 화면을 랜더링 하는 일에 집중할 수 있다.
- 뷰: 모델에 담겨있는 데이터를 사용해서 화면을 그리는 일에 집중한다. 여기서는 HTML을 생성하는 부분을 말한다.

- 뷰는 랜더링하는 역할!
- 하지만 컨트롤러는 뭔가 중복이 많다. 중복되는것을 util 로 빼더라도 호출해야하는 중복
- viewPath 중복 위치가 변경되면 유지보수 지옥
- Request, Response 객체 사용하지 않을때가 있다.
- 공통처리를 해야한다!!!

### 프론트 컨트롤러의 등장
- 공통로직을 프론트 컨트롤러에 몰고, 각자 필요한 로직은 각 컨트롤러에서 처리한다.
- 원래는 고객요청을 서블릿 컨트롤러가 직접 받았지만, 이제는 프론트컨트롤러에서 모든 고객요청을 처리한뒤 각 컨트롤러로 넘겨준다.
- 그래서 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도된다.
- 구조는 바꾸었지만 각 컨트롤러 부분에 아직 중복 코드 존재한다.

### View 분리
```java
String viewPath = "/WEB-INF/views/new-form.jsp";
RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
dispatcher.forward(request, response);
```

이부분을 깔끔하게 처리하기 위해서 뷰를 처리하는 객체를 만들자


